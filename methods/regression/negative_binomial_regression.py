# -*- coding: utf-8 -*-
"""Negative Binomial Regression 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hxRKLUiZhrJWZmi-Vjkajgih0HO9LI-K
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
#collisions = pd.read_csv("/content/drive/My Drive/MIE368 Project - Group 15/Code/collisions_dataset/collisions_dataset_new/collisions_enriched.csv")
#speed_cameras = pd.read_csv("/content/drive/My Drive/MIE368 Project - Group 15/Code/speed_camera_dataset/speed_camera_clean_new/speed_cameras_clean.csv")

collisions = pd.read_csv("/content/drive/My Drive/UofT/Third Year/Fall/MIE368 Project - Group 15/Code/collisions_dataset/collisions_dataset_new/collisions_enriched.csv")
speed_cameras = pd.read_csv("/content/drive/My Drive/UofT/Third Year/Fall/MIE368 Project - Group 15/Code/speed_camera_dataset/speed_camera_clean_new/speed_cameras_clean.csv")

print("Collisions data:")
collisions.head()

print("\nSpeed cameras data:")
speed_cameras[speed_cameras['status_clean'] == 'active']

import geopandas as gpd
from shapely.geometry import Point

# convert collisions to GeoDataFrame
collisions_gdf = gpd.GeoDataFrame(
    collisions,
    geometry=gpd.points_from_xy(collisions.lon, collisions.lat),
    crs="EPSG:4326"
).to_crs("EPSG:3857")

# convert cameras to GeoDataFrame
speed_gdf = gpd.GeoDataFrame(
    speed_cameras,
    geometry=gpd.points_from_xy(speed_cameras.lon, speed_cameras.lat),
    crs="EPSG:4326"
).to_crs("EPSG:3857")

from shapely.geometry import box

collisions_gdf = collisions_gdf.to_crs(epsg=32617)
speed_gdf = speed_gdf.to_crs(epsg=32617)

# create a spatial grid (500m x 500m) to aggregate collisions
xmin, ymin, xmax, ymax = collisions_gdf.total_bounds
cell_size = 500  # in meters

cols = list(range(int(xmin), int(xmax) + cell_size, cell_size))
rows = list(range(int(ymin), int(ymax) + cell_size, cell_size))

grid_cells = []
for x in cols:
    for y in rows:
        grid_cells.append(box(x, y, x + cell_size, y + cell_size))

grid = gpd.GeoDataFrame({'geometry': grid_cells}, crs=collisions_gdf.crs)

# changed to .intersects(poly)
grid["collision_count"] = grid.geometry.apply(
    lambda poly: collisions_gdf.intersects(poly).sum()
)

grid["camera_count"] = grid.geometry.apply(
    lambda poly: speed_gdf.intersects(poly).sum()
)

def mean_dist(poly):
    pts = collisions_gdf[collisions_gdf.intersects(poly)]
    return pts["cam_nearest_m"].mean() if len(pts) > 0 else 0

grid["mean_dist_to_camera"] = grid.geometry.apply(mean_dist)

def mean_col(poly, col):
    pts = collisions_gdf[collisions_gdf.intersects(poly)]
    return pts[col].mean() if len(pts) > 0 else 0

grid["mean_precip"] = grid.geometry.apply(lambda p: mean_col(p, "wx_precipitation"))
grid["mean_snow"]   = grid.geometry.apply(lambda p: mean_col(p, "wx_snow"))

# Downtown Toronto
downtown_poly = gpd.GeoSeries(
    [box(-79.42, 43.63, -79.34, 43.67)],
    crs="EPSG:4326"
).to_crs(32617)[0]

grid["downtown"] = grid.geometry.apply(
    lambda g: 1 if g.intersects(downtown_poly) else 0
)

import statsmodels.formula.api as smf
import statsmodels.api as sm

model2 = smf.glm(
    formula="collision_count ~ camera_count + mean_dist_to_camera + mean_precip + mean_snow + downtown",
    data=grid,
    family=sm.families.NegativeBinomial()
).fit()

print("\nMODEL 2 — Negative Binomial Regression")
print(model2.summary())

import math

coef_camera_count = model2.params['camera_count']
print("Coefficient for camera_count:", coef_camera_count)

irr_camera_count = math.exp(coef_camera_count)
print(f"IRR for camera_count: {irr_camera_count:.3f}") # Incidence Rate Ratio (IRR)

grid["lambda"] = model2.predict(grid)

"""## Model 2: Negative Binomial Regression Results

This model predicts the **count of collisions** within 500m × 500m spatial grid cells using the number of speed cameras (`camera_count`) in each cell.

### Interpretation:
- The **positive and significant coefficient** for `camera_count` indicates that grid cells with more cameras currently also have more collisions.
- The **IRR** is approximately 2.97, meaning the expected number of collisions **nearly triples** for each additional camera in a cell.
- **Important:** This does **not** mean cameras cause collisions. Rather, current cameras are placed in historically high-collision areas.

### Weather and Other Biases:
- **Mean Precipitation (`mean_precip`)** has a strong positive effect on collision counts. A **1-unit increase** in precipitation leads to a substantial **increase in collision frequency** (IRR of 2.611), indicating that **rainy conditions** contribute to more collisions.
- **Mean Snow (`mean_snow`)** has a negative relationship with collisions, but this is less impactful. The **IRR of -0.483** suggests that snow **reduces collision frequency** slightly, potentially because of reduced speeds during snowy weather.
- **Distance to Nearest Camera (`mean_dist_to_camera`)** is positive and significant, meaning that collisions are more likely in areas that are **farther from cameras**, which may indicate **gaps in camera coverage** or that cameras are **concentrated in high-risk areas**.
- **Downtown Flag (`downtown`)** has a positive coefficient (IRR of 1.148), meaning that **downtown areas** experience **more collisions** and are likely **overrepresented** in the model, which could skew results.

### Implications for Camera Placement:
- While cameras currently align with high-risk areas, the large IRR suggests that there are **other high-collision locations with few or no cameras**.
- This indicates opportunities to **optimize camera placement** to reduce collisions in under-covered areas.

### Coefficient for `camera_count`:
0.9537

### IRR for `camera_count`:
2.595

### Conclusion:
The model highlights that speed cameras are indeed placed in areas with higher collisions, but there may be **untapped potential** in other **high-risk areas**.
- The **IRR value of 2.595** points to a significant effect of camera placement on collision rates, suggesting a need for **strategic relocation** or **additional placement** of cameras in currently **under-served locations**.
"""