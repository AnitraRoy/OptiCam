# -*- coding: utf-8 -*-
"""baseline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14zLrckUXwDJPpeDwsjq3CSh_d9A7uJ6a
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
from scipy import stats
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans, DBSCAN
import geopandas as gpd
from scipy.spatial import cKDTree
import folium
from folium.plugins import MarkerCluster
import matplotlib.cm as cm
import matplotlib.colors as colors

collisions = pd.read_csv("/content/drive/My Drive/MIE368 Project - Group 15/Code/collisions_dataset/collisions_dataset_new/collisions_enriched.csv")
speed_cameras = pd.read_csv("/content/drive/My Drive/MIE368 Project - Group 15/Code/speed_camera_dataset/speed_camera_clean_new/speed_cameras_clean.csv")

print(collisions.head())

print(speed_cameras.head())

collisions = collisions.dropna(subset=['lat', 'lon'])
speed_cameras = speed_cameras.dropna(subset=['lat', 'lon'])

# convert to GeoDataFrames
coll_gdf = gpd.GeoDataFrame(collisions, geometry=gpd.points_from_xy(collisions['lon'], collisions['lat']), crs="EPSG:4326")
cam_gdf  = gpd.GeoDataFrame(speed_cameras, geometry=gpd.points_from_xy(speed_cameras['lon'], speed_cameras['lat']), crs="EPSG:4326")

# convert to UTM (meters)
coll_utm = coll_gdf.to_crs(epsg=32617)
cam_utm = cam_gdf.to_crs(epsg=32617)

# build KD-Tree for nearest-neighbour distance
camera_coords = np.array(list(zip(cam_utm.geometry.x, cam_utm.geometry.y)))
collision_coords = np.array(list(zip(coll_utm.geometry.x, coll_utm.geometry.y)))

tree = cKDTree(camera_coords)
distances, _ = tree.query(collision_coords, k=1)
coll_utm['distance_to_camera_m'] = distances

# 500m buffer coverage
buffer_radius = 500
cam_utm['buffer'] = cam_utm.geometry.buffer(buffer_radius)
all_buffers = cam_utm['buffer'].unary_union

coll_utm['within_500m'] = coll_utm.geometry.within(all_buffers)

coverage_rate = coll_utm['within_500m'].mean()
avg_distance = coll_utm['distance_to_camera_m'].mean()

print("\nBaseline Coverage:")
print(f"Collision Coverage Within 500m: {coverage_rate:.3f}")
print(f"Average Distance to Nearest Camera (m): {avg_distance:.1f}")

# add Near/Far field for statistical tests
coll_utm['near_far'] = np.where(coll_utm['within_500m'], 'Near', 'Far')

print(collisions.columns.tolist())

# weather-collision correlation
daily_data = (
    collisions.groupby('date')
    .agg({'severity':'count','wx_precip_amount_any':'mean','wx_snow':'mean'})
    .rename(columns={'severity':'collision_count'})
    .dropna()
    .reset_index()
)

corr_precip, p_precip = stats.pearsonr(daily_data['wx_precip_amount_any'], daily_data['collision_count'])
corr_snow, p_snow = stats.pearsonr(daily_data['wx_snow'], daily_data['collision_count'])

print("\nWeather Coverage:")
print(f"Precipitation vs Collisions: r={corr_precip:.3f}, p={p_precip}")
print(f"Snow vs Collisions:          r={corr_snow:.3f}, p={p_snow}")

# severity encoding
coll_utm['severity_num'] = coll_utm['severity'].map({
    'Property Damage Only': 1,
    'Injury': 2,
    'Non-Fatal Injury': 2,
    'Fatal': 3
})

# time of day for biases
coll_utm['day_night'] = coll_utm['hour'].apply(lambda h: 'Day' if 7 <= h <= 18 else 'Night')

# Statistical Tests
# T-test: Severity near vs far
near = coll_utm[coll_utm['near_far']=='Near']['severity_num']
far = coll_utm[coll_utm['near_far']=='Far']['severity_num']

sample_n = min(len(near), len(far), 10000)
near_s = near.sample(sample_n, random_state=42)
far_s = far.sample(sample_n, random_state=42)

t,p = stats.ttest_ind(near_s, far_s, equal_var=False)

print("T-Test: Near vs Far")
print(f"t={t:.4f}, p={p:.6f}")

# Chi-square tests
print("\nCh-Squared Test")

chi1 = stats.chi2_contingency(pd.crosstab(coll_utm['severity'], coll_utm['near_far']))
chi2 = stats.chi2_contingency(pd.crosstab(coll_utm['day_night'], coll_utm['severity']))

print(f"Severity vs Camera Presence: p={chi1[1]}")
print(f"Lighting vs Severity:        p={chi2[1]}")

# ANOVA across months
coll_utm['month'] = pd.to_datetime(coll_utm['date'], errors='coerce').dt.month
anova_groups = [g['severity_num'].sample(min(len(g), 10000), random_state=42)
                for _,g in coll_utm.groupby('month') if g['severity_num'].nunique()>1]

f,p = stats.f_oneway(*anova_groups)
print("\nANOVA: Monthly Severity")
print(f"F={f:.4f}, p={p}")

# K-Means clustering
coords = collisions[['lon','lat']].dropna()
kmeans = KMeans(n_clusters=4, n_init=10, random_state=42)
collisions['k_cluster'] = kmeans.fit_predict(coords)

print("\nK-Means Cluster:")
print(collisions['k_cluster'].value_counts(normalize=True))

# DBSCAN Hotspot Clustering
coords_utm = np.array(list(zip(coll_utm.geometry.x, coll_utm.geometry.y)))
db = DBSCAN(eps=300, min_samples=5).fit(coords_utm)
coll_utm['db_cluster'] = db.labels_

print("\nDBSCAN Hotspots:")
print(coll_utm['db_cluster'].value_counts())

# hotspots outside camera coverage
hotspots = coll_utm[coll_utm['db_cluster'] != -1]
hotspots_outside = hotspots[~hotspots['within_500m']]
print(f"Hotspots outside camera zones: {len(hotspots_outside)}")

# calculate tot # of collision points and number of points covered by cameras
total_collisions = len(coll_utm)
covered_collisions = coll_utm['within_500m'].sum()

# calculate the coverage percentage
coverage_percent_baseline = (covered_collisions / total_collisions) * 100
print(f"Coverage Percentage: {coverage_percent_baseline:.2f}%")

# Baseline summary table

summary = pd.DataFrame({
    "Metric": [
        "Coverage rate (500m)",
        "Avg distance to nearest camera (m)",
        "Precipitation correlation",
        "Snow correlation",
        "T-test p-value (Near vs Far severity)",
        "Chi-square p: severity vs camera",
        "Chi-square p: lighting vs severity",
        "ANOVA p-value (seasonal severity)",
        "DBSCAN hotspots",
        "Hotspots outside coverage",
        "Baseline Coverage Percentage"
    ],
    "Value": [
        coverage_rate,
        avg_distance,
        corr_precip,
        corr_snow,
        p,
        chi1[1],
        chi2[1],
        p,
        len(hotspots),
        len(hotspots_outside),
        coverage_percent_baseline
    ]
})


print("\n\nBaseline Summary:")
print(summary)